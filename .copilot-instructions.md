# GitHub Copilot Instructions - mark2

This file provides GitHub Copilot with context and guidelines for the mark2 project.

## Project Context
- **Project**: mark2 - Markdown to Mind Map converter
- **Language**: Vanilla JavaScript (ES6+), no frameworks
- **Architecture**: Atomic Design pattern
- **Styling**: CSS3 with custom properties, mobile-first approach
- **Purpose**: Convert markdown text into interactive SVG mind maps

## Code Style Guidelines

### JavaScript Conventions
- Use `const` and `let`, avoid `var`
- Prefer arrow functions for callbacks
- Use template literals for string interpolation
- ES6 modules (import/export)
- No semicolons (consistent with project style)
- PascalCase for component names, camelCase for functions/variables

```javascript
// Good
const parseMarkdown = (text) => {
  const lines = text.split('\n')
  return lines.filter(line => line.trim())
}

export default parseMarkdown
```

### Component Structure (Atomic Design)
```javascript
// Atomic component example
class Button {
  constructor(text, onClick, variant = 'primary') {
    this.text = text
    this.onClick = onClick
    this.variant = variant
  }

  render() {
    const button = document.createElement('button')
    button.className = `atom-button atom-button--${this.variant}`
    button.textContent = this.text
    button.addEventListener('click', this.onClick)
    return button
  }
}

export default Button
```

### CSS Guidelines
- Mobile-first responsive design
- Use CSS custom properties for theming
- BEM-like naming convention for atomic design
- Prefix classes with component level (atom-, molecule-, organism-)

```css
/* Component CSS structure */
.atom-button {
  padding: var(--spacing-sm);
  border: 1px solid var(--color-border);
  background: var(--color-bg-primary);
  color: var(--color-text-primary);
  border-radius: var(--border-radius);
  font-family: var(--font-family);
}

.atom-button--primary {
  background: var(--color-accent);
  color: var(--color-text-inverse);
}
```

## File Organization Pattern
```
src/
├── atoms/ComponentName/
│   ├── index.js           # Main component logic
│   ├── ComponentName.css  # Component styles
│   └── ComponentName.test.js # Unit tests
```

## Common Patterns to Follow

### Component Creation
When creating new components, always include:
1. Constructor with clear parameters
2. Render method that returns DOM element
3. Event handling where appropriate
4. CSS class following naming convention
5. Unit tests

### Utility Functions
Keep utility functions pure and testable:
```javascript
// utils/markdownParser.js
export const parseHeaders = (text) => {
  const headerRegex = /^(#{1,6})\s+(.+)$/gm
  const headers = []
  let match

  while ((match = headerRegex.exec(text)) !== null) {
    headers.push({
      level: match[1].length,
      text: match[2].trim(),
      index: match.index
    })
  }

  return headers
}
```

### Theme Integration
Always use CSS custom properties for colors and sizing:
```javascript
// theme/ThemeManager.js
class ThemeManager {
  constructor() {
    this.currentTheme = 'light'
    this.themes = ['light', 'dark', 'blue', 'green', 'orange']
  }

  setTheme(themeName) {
    if (!this.themes.includes(themeName)) return false

    document.body.className = `theme-${themeName}`
    this.currentTheme = themeName
    localStorage.setItem('preferred-theme', themeName)
    return true
  }
}
```

## Specific Component Types

### Atoms (Basic Components)
- Button, TextInput, Icon, Node, Connection
- Single responsibility
- No dependencies on other components
- Pure functions when possible

### Molecules (Component Combinations)
- Toolbar (multiple buttons), TextEditor (input + controls)
- Combine 2-3 atoms
- Handle specific interactions

### Organisms (Complex Sections)
- EditorPanel, MindMap, Header
- Complete functional sections
- Manage state and complex interactions

## Mind Map Specific Patterns

### Node Structure
```javascript
class Node {
  constructor(text, level, x = 0, y = 0) {
    this.text = text
    this.level = level
    this.x = x
    this.y = y
    this.children = []
    this.parent = null
  }

  addChild(childNode) {
    childNode.parent = this
    this.children.push(childNode)
  }
}
```

### SVG Rendering
```javascript
// Use SVG for mind map visualization
const createSVGElement = (tag, attributes = {}) => {
  const element = document.createElementNS('http://www.w3.org/2000/svg', tag)
  Object.entries(attributes).forEach(([key, value]) => {
    element.setAttribute(key, value)
  })
  return element
}
```

## Testing Patterns
```javascript
// ComponentName.test.js
import Component from './index.js'

describe('ComponentName', () => {
  test('should render with correct text', () => {
    const component = new Component('Test Text')
    const element = component.render()

    expect(element.textContent).toBe('Test Text')
    expect(element.classList.contains('atom-component')).toBe(true)
  })
})
```

## Mobile-First Responsive Approach
```css
/* Mobile first (default) */
.organism-editor-panel {
  width: 100%;
  height: 50vh;
}

/* Tablet */
@media (min-width: 768px) {
  .organism-editor-panel {
    height: 40vh;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .organism-editor-panel {
    width: 50%;
    height: 100vh;
  }
}
```

## Error Handling
```javascript
// Always handle errors gracefully
const parseMarkdown = (text) => {
  try {
    if (!text || typeof text !== 'string') {
      throw new Error('Invalid markdown text provided')
    }

    return processMarkdown(text)
  } catch (error) {
    console.error('Markdown parsing error:', error)
    return { error: 'Failed to parse markdown', nodes: [] }
  }
}
```

## Performance Considerations
- Use event delegation for dynamic content
- Implement lazy loading for large mind maps
- Debounce user input for real-time parsing
- Use requestAnimationFrame for smooth animations

Remember: This project prioritizes simplicity, maintainability, and performance while following atomic design principles strictly.