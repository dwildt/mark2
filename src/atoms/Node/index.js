/**\n * Node Atom Component\n * Individual node element for mind maps\n */\n\nclass Node {\n  constructor(text, level = 1, x = 0, y = 0, options = {}) {\n    this.text = text\n    this.level = level\n    this.x = x\n    this.y = y\n    this.width = options.width || 0\n    this.height = options.height || 0\n    this.id = options.id || `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    \n    // Hierarchy\n    this.parent = null\n    this.children = []\n    \n    // State\n    this.selected = false\n    this.hovered = false\n    this.expanded = true\n    \n    // Event handlers\n    this.onClick = options.onClick || null\n    this.onDoubleClick = options.onDoubleClick || null\n    this.onHover = options.onHover || null\n    \n    // DOM elements\n    this.element = null\n    this.textElement = null\n  }\n\n  addChild(childNode) {\n    if (childNode && !this.children.includes(childNode)) {\n      childNode.parent = this\n      this.children.push(childNode)\n    }\n    return this\n  }\n\n  removeChild(childNode) {\n    const index = this.children.indexOf(childNode)\n    if (index > -1) {\n      this.children.splice(index, 1)\n      childNode.parent = null\n    }\n    return this\n  }\n\n  getDepth() {\n    let depth = 0\n    let current = this.parent\n    while (current) {\n      depth++\n      current = current.parent\n    }\n    return depth\n  }\n\n  isRoot() {\n    return this.parent === null\n  }\n\n  isLeaf() {\n    return this.children.length === 0\n  }\n\n  renderSVG() {\n    if (this.element) {\n      return this.element\n    }\n\n    // Create group element for the node\n    this.element = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n    this.element.setAttribute('class', this.getClassName())\n    this.element.setAttribute('id', this.id)\n    this.element.setAttribute('transform', `translate(${this.x}, ${this.y})`)\n    \n    // Calculate text dimensions\n    this.calculateDimensions()\n    \n    // Create background rectangle\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n    rect.setAttribute('class', 'mind-map-node__background')\n    rect.setAttribute('x', -this.width / 2)\n    rect.setAttribute('y', -this.height / 2)\n    rect.setAttribute('width', this.width)\n    rect.setAttribute('height', this.height)\n    rect.setAttribute('rx', 6) // Border radius\n    \n    // Create text element\n    this.textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n    this.textElement.setAttribute('class', 'mind-map-node__text')\n    this.textElement.setAttribute('text-anchor', 'middle')\n    this.textElement.setAttribute('dominant-baseline', 'central')\n    this.textElement.textContent = this.text\n    \n    // Add elements to group\n    this.element.appendChild(rect)\n    this.element.appendChild(this.textElement)\n    \n    // Attach event listeners\n    this.attachEventListeners()\n    \n    return this.element\n  }\n\n  calculateDimensions() {\n    // Create temporary text element to measure dimensions\n    const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n    tempText.setAttribute('class', 'mind-map-node__text')\n    tempText.textContent = this.text\n    tempText.style.visibility = 'hidden'\n    \n    // Add to DOM temporarily to measure\n    const svg = document.querySelector('#mind-map-svg')\n    if (svg) {\n      svg.appendChild(tempText)\n      const bbox = tempText.getBBox()\n      svg.removeChild(tempText)\n      \n      // Add padding\n      const padding = 16\n      this.width = Math.max(bbox.width + padding * 2, 80) // Minimum width\n      this.height = Math.max(bbox.height + padding, 40) // Minimum height\n    } else {\n      // Fallback dimensions\n      this.width = Math.max(this.text.length * 8, 80)\n      this.height = 40\n    }\n  }\n\n  getClassName() {\n    const baseClass = 'mind-map-node'\n    const levelClass = `mind-map-node--level-${this.level}`\n    const selectedClass = this.selected ? 'mind-map-node--selected' : ''\n    const hoveredClass = this.hovered ? 'mind-map-node--hovered' : ''\n    const rootClass = this.isRoot() ? 'mind-map-node--root' : ''\n    const leafClass = this.isLeaf() ? 'mind-map-node--leaf' : ''\n    \n    return [baseClass, levelClass, selectedClass, hoveredClass, rootClass, leafClass]\n      .filter(Boolean)\n      .join(' ')\n  }\n\n  attachEventListeners() {\n    if (!this.element) return\n    \n    // Click handler\n    if (this.onClick) {\n      this.element.addEventListener('click', (event) => {\n        event.stopPropagation()\n        this.onClick(this, event)\n      })\n    }\n    \n    // Double click handler\n    if (this.onDoubleClick) {\n      this.element.addEventListener('dblclick', (event) => {\n        event.stopPropagation()\n        this.onDoubleClick(this, event)\n      })\n    }\n    \n    // Hover handlers\n    this.element.addEventListener('mouseenter', (event) => {\n      this.setHovered(true)\n      if (this.onHover) {\n        this.onHover(this, true, event)\n      }\n    })\n    \n    this.element.addEventListener('mouseleave', (event) => {\n      this.setHovered(false)\n      if (this.onHover) {\n        this.onHover(this, false, event)\n      }\n    })\n    \n    // Keyboard navigation\n    this.element.setAttribute('tabindex', '0')\n    this.element.addEventListener('keydown', this.handleKeyDown.bind(this))\n  }\n\n  handleKeyDown(event) {\n    switch (event.key) {\n      case 'Enter':\n      case ' ':\n        event.preventDefault()\n        if (this.onClick) {\n          this.onClick(this, event)\n        }\n        break\n      case 'Escape':\n        this.setSelected(false)\n        break\n    }\n  }\n\n  setPosition(x, y) {\n    this.x = x\n    this.y = y\n    if (this.element) {\n      this.element.setAttribute('transform', `translate(${x}, ${y})`)\n    }\n    return this\n  }\n\n  setText(newText) {\n    this.text = newText\n    if (this.textElement) {\n      this.textElement.textContent = newText\n      this.calculateDimensions()\n      this.updateBackground()\n    }\n    return this\n  }\n\n  updateBackground() {\n    if (!this.element) return\n    \n    const rect = this.element.querySelector('.mind-map-node__background')\n    if (rect) {\n      rect.setAttribute('x', -this.width / 2)\n      rect.setAttribute('y', -this.height / 2)\n      rect.setAttribute('width', this.width)\n      rect.setAttribute('height', this.height)\n    }\n  }\n\n  setSelected(selected) {\n    this.selected = selected\n    if (this.element) {\n      this.element.setAttribute('class', this.getClassName())\n    }\n    return this\n  }\n\n  setHovered(hovered) {\n    this.hovered = hovered\n    if (this.element) {\n      this.element.setAttribute('class', this.getClassName())\n    }\n    return this\n  }\n\n  setLevel(level) {\n    this.level = level\n    if (this.element) {\n      this.element.setAttribute('class', this.getClassName())\n    }\n    return this\n  }\n\n  getBounds() {\n    return {\n      x: this.x - this.width / 2,\n      y: this.y - this.height / 2,\n      width: this.width,\n      height: this.height,\n      centerX: this.x,\n      centerY: this.y\n    }\n  }\n\n  getConnectionPoint(direction = 'right') {\n    const bounds = this.getBounds()\n    \n    switch (direction) {\n      case 'right':\n        return { x: bounds.x + bounds.width, y: bounds.centerY }\n      case 'left':\n        return { x: bounds.x, y: bounds.centerY }\n      case 'top':\n        return { x: bounds.centerX, y: bounds.y }\n      case 'bottom':\n        return { x: bounds.centerX, y: bounds.y + bounds.height }\n      default:\n        return { x: bounds.centerX, y: bounds.centerY }\n    }\n  }\n\n  animate(properties, duration = 300) {\n    if (!this.element) return Promise.resolve()\n    \n    return new Promise((resolve) => {\n      const startTime = performance.now()\n      const startProps = {\n        x: this.x,\n        y: this.y\n      }\n      \n      const animate = (currentTime) => {\n        const elapsed = currentTime - startTime\n        const progress = Math.min(elapsed / duration, 1)\n        \n        // Easing function (ease-out)\n        const eased = 1 - Math.pow(1 - progress, 3)\n        \n        if (properties.x !== undefined) {\n          const newX = startProps.x + (properties.x - startProps.x) * eased\n          this.setPosition(newX, this.y)\n        }\n        \n        if (properties.y !== undefined) {\n          const newY = startProps.y + (properties.y - startProps.y) * eased\n          this.setPosition(this.x, newY)\n        }\n        \n        if (progress < 1) {\n          requestAnimationFrame(animate)\n        } else {\n          resolve()\n        }\n      }\n      \n      requestAnimationFrame(animate)\n    })\n  }\n\n  destroy() {\n    if (this.element && this.element.parentNode) {\n      this.element.parentNode.removeChild(this.element)\n    }\n    this.element = null\n    this.textElement = null\n    \n    // Clean up hierarchy\n    this.children.forEach(child => child.destroy())\n    this.children = []\n    this.parent = null\n  }\n}\n\nexport default Node